// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Char = require("rescript/lib/js/char.js");
var List = require("rescript/lib/js/list.js");
var Curry = require("rescript/lib/js/curry.js");
var $$String = require("rescript/lib/js/string.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Pervasives = require("rescript/lib/js/pervasives.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Caml_string = require("rescript/lib/js/caml_string.js");

function run(t, input) {
  return Curry._1(t._0, input);
}

function bind(t, fn) {
  return /* Parser */{
          _0: (function (input) {
              var msg = run(t, input);
              if (msg.TAG !== /* Ok */0) {
                return {
                        TAG: /* Error */1,
                        _0: msg._0
                      };
              }
              var match = msg._0;
              return run(Curry._1(fn, match[0]), match[1]);
            })
        };
}

function $$return(x) {
  return /* Parser */{
          _0: (function (input) {
              return {
                      TAG: /* Ok */0,
                      _0: [
                        x,
                        input
                      ]
                    };
            })
        };
}

function map(t, fn) {
  return bind(t, (function (x) {
                return $$return(Curry._1(fn, x));
              }));
}

function andThen(p1, p2) {
  return bind(p1, (function (res1) {
                return bind(p2, (function (res2) {
                              return $$return([
                                          res1,
                                          res2
                                        ]);
                            }));
              }));
}

function satisfy(predicate) {
  return /* Parser */{
          _0: (function (input) {
              var $$char;
              try {
                $$char = Caml_string.get(input, 0);
              }
              catch (exn){
                $$char = undefined;
              }
              if ($$char !== undefined) {
                if (Curry._1(predicate, $$char)) {
                  return {
                          TAG: /* Ok */0,
                          _0: [
                            $$char,
                            $$String.sub(input, 1, input.length - 1 | 0)
                          ]
                        };
                } else {
                  return {
                          TAG: /* Error */1,
                          _0: "Unexpected " + Char.escaped($$char)
                        };
                }
              } else {
                return {
                        TAG: /* Error */1,
                        _0: "No more input"
                      };
              }
            })
        };
}

function $$char(expected) {
  return satisfy(function (param) {
              return Char.equal(expected, param);
            });
}

function orElse(parser1, parser2) {
  return /* Parser */{
          _0: (function (input) {
              var result = run(parser1, input);
              if (result.TAG === /* Ok */0) {
                return result;
              } else {
                return run(parser2, input);
              }
            })
        };
}

function choice(parsers) {
  return Belt_Array.reduce(parsers, /* Parser */{
              _0: (function (param) {
                  return {
                          TAG: /* Error */1,
                          _0: "Initial parser"
                        };
                })
            }, orElse);
}

function anyOf(chars) {
  return choice(Belt_Array.map(chars, $$char));
}

function apply(parserA, parserB) {
  return bind(parserB, (function (f) {
                return bind(parserA, (function (x) {
                              return $$return(Curry._1(f, x));
                            }));
              }));
}

function lift2(parserA, fn, parserB) {
  return apply(parserB, apply(parserA, $$return(fn)));
}

function sequence(parsers) {
  if (parsers) {
    return lift2(parsers.hd, List.cons, sequence(parsers.tl));
  } else {
    return /* Parser */{
            _0: (function (input) {
                return {
                        TAG: /* Ok */0,
                        _0: [
                          /* [] */0,
                          input
                        ]
                      };
              })
          };
  }
}

function zeroOrMore(parser, input) {
  var match = run(parser, input);
  if (match.TAG !== /* Ok */0) {
    return [
            /* [] */0,
            input
          ];
  }
  var match$1 = match._0;
  var match$2 = zeroOrMore(parser, match$1[1]);
  return [
          {
            hd: match$1[0],
            tl: match$2[0]
          },
          match$2[1]
        ];
}

function many(parser) {
  return /* Parser */{
          _0: (function (input) {
              return {
                      TAG: /* Ok */0,
                      _0: zeroOrMore(parser, input)
                    };
            })
        };
}

function atLeastOne(parser) {
  return bind(parser, (function (head) {
                return bind(many(parser), (function (tail) {
                              return $$return({
                                          hd: head,
                                          tl: tail
                                        });
                            }));
              }));
}

function keepLeft(parserA, parserB) {
  return map(andThen(parserA, parserB), (function (prim) {
                return prim[0];
              }));
}

function keepRight(parserA, parserB) {
  return map(andThen(parserA, parserB), (function (prim) {
                return prim[1];
              }));
}

function between(parserA, parserB, parserC) {
  return keepLeft(keepRight(parserB, parserA), parserC);
}

function separatedBy1(parser, separator) {
  var separators = keepRight(separator, parser);
  return map(andThen(parser, many(separators)), (function (param) {
                return {
                        hd: param[0],
                        tl: param[1]
                      };
              }));
}

function separatedBy(parser, separator) {
  return orElse(separatedBy1(parser, separator), /* Parser */{
              _0: (function (input) {
                  return {
                          TAG: /* Ok */0,
                          _0: [
                            /* [] */0,
                            input
                          ]
                        };
                })
            });
}

function string(x) {
  return map(map(map(sequence(Belt_List.fromArray(Belt_Array.map(Belt_Array.map(x.split(""), (function (__x) {
                                        return Caml_string.get(__x, 0);
                                      })), $$char))), (function (__x) {
                        return Belt_List.map(__x, Char.escaped);
                      })), Belt_List.toArray), (function (param) {
                return param.join("");
              }));
}

function makeForwardRef(param) {
  var parser = /* Parser */{
    _0: (function (param) {
        return Pervasives.failwith("Not implemented");
      })
  };
  var parserRef = {
    contents: parser
  };
  return [
          /* Parser */{
            _0: (function (input) {
                return run(parserRef.contents, input);
              })
          },
          parserRef
        ];
}

function makeRecursive(fn) {
  var match = makeForwardRef(undefined);
  var parserRef = match[1];
  parserRef.contents = Curry._1(fn, match[0]);
  return parserRef.contents;
}

function optional(parser) {
  var some = map(parser, (function (x) {
          return Caml_option.some(x);
        }));
  var none = /* Parser */{
    _0: (function (input) {
        return {
                TAG: /* Ok */0,
                _0: [
                  undefined,
                  input
                ]
              };
      })
  };
  return orElse(some, none);
}

exports.run = run;
exports.bind = bind;
exports.$$return = $$return;
exports.map = map;
exports.andThen = andThen;
exports.satisfy = satisfy;
exports.$$char = $$char;
exports.orElse = orElse;
exports.choice = choice;
exports.anyOf = anyOf;
exports.apply = apply;
exports.lift2 = lift2;
exports.sequence = sequence;
exports.zeroOrMore = zeroOrMore;
exports.many = many;
exports.atLeastOne = atLeastOne;
exports.keepLeft = keepLeft;
exports.keepRight = keepRight;
exports.between = between;
exports.separatedBy1 = separatedBy1;
exports.separatedBy = separatedBy;
exports.string = string;
exports.makeForwardRef = makeForwardRef;
exports.makeRecursive = makeRecursive;
exports.optional = optional;
/* No side effect */
