module P = Parser

let getFileContents = (~dir, ~name) =>
  NodeJs.Fs.readFileSyncWith(
    dir ++ "/" ++ name,
    NodeJs.Fs.readFileOptions(~encoding="utf-8", ()),
  )->NodeJs.Buffer.toString

let test_a = {
  let parser = {
    let whitespace = P.anyOf([' ', '\n'])

    P.string("hello")
    //
    ->P.keepLeft(whitespace)
    ->P.andThen(P.string("12"))
  }
  let test_a = getFileContents(~dir="spec", ~name="test_1")

  let result = parser->P.run(test_a)

  switch result {
  | Ok((("hello", "12"), "")) => Js.log("ok")
  | Ok((_, "")) => Js.log2("Error", "Unexpected")
  | Ok((_, remaining)) => Js.log2("Error", remaining)
  | Error(e) => Js.log(e)
  }
}

let test_b = {
  let test_b = getFileContents(~dir="spec", ~name="test_2")

  let parser = {
    P.char('a')->P.andThen(P.char('b'))->P.andThen(P.char('c'))
  }

  switch parser->P.run(test_b) {
  | Ok(_) => Js.log("Ok 2")
  | Error(e) => Js.log2("Error 2", e)
  }
}

type rec lispAst =
  | Int(string)
  | String(string)
  | Sexp(string, list<lispAst>)

let testC = {
  let parser = P.makeRecursive(p => {
    let lowercase = P.satisfy(c => c >= 'a' && 'z' >= c)
    let uppercase = P.satisfy(c => c >= 'A' && 'Z' >= c)
    let letter = P.orElse(lowercase, uppercase)
    let digit = P.satisfy(c => c >= '0' && '9' >= c)
    let doubleQuote = P.char('"')
    let whitespace = P.char(' ')

    let stringFromCharList = parser => {
      parser
      ->P.map(Belt.List.map(_, String.make(0)))
      ->P.map(Belt.List.reduce(_, "", Js.String2.concat))
    }

    let int = P.atLeastOne(digit)->stringFromCharList

    let string = {
      P.orElse(letter, digit)->P.many->P.between(doubleQuote, _, doubleQuote)->stringFromCharList
    }

    let sexp = {
      P.char('(')
      ->P.keepRight(P.many(whitespace))
      ->P.keepRight(P.atLeastOne(letter))
      ->P.keepLeft(P.many(whitespace))
      ->P.andThen(P.many(P.orElse(string->P.map(x => String(x)), int->P.map(x => Int(x)))))
      ->P.map(((name, vals)) => {
        let name =
          name->Belt.List.map(_, String.make(0))->Belt.List.reduce(_, "", Js.String2.concat)

        Sexp(name, vals)
      })
      ->P.keepLeft(P.many(whitespace))
      ->P.keepLeft(P.char(')'))
    }

    P.choice([
      //
      sexp,
      int->P.map(int => Int(int)),
      string->P.map(string => String(string)),
    ])->P.separatedBy(whitespace)
  })

  let result = P.run(parser, getFileContents(~dir="spec", ~name="lisp_full"))

  switch result {
  | Error(_) => Js.log("Error")
  | Ok((_ast, "")) => Js.log("Test C was okay")
  | Ok((_, rest)) => Js.log2("Test C Error", rest)
  }
}

Ava.todo("Test large file")
