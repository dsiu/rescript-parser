// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Ava = require("rescript-ava/src/ava.cjs");
var Parser = require("../../src/parser.cjs");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Simple_sexp_parser = require("./simple_sexp_parser.cjs");

Ava.test("[Sexps] Char list to string", (function (t) {
        return Ava.is(t, Simple_sexp_parser.charListToString({
                        hd: /* 'h' */104,
                        tl: {
                          hd: /* 'e' */101,
                          tl: {
                            hd: /* 'l' */108,
                            tl: {
                              hd: /* 'l' */108,
                              tl: {
                                hd: /* 'o' */111,
                                tl: /* [] */0
                              }
                            }
                          }
                        }
                      }), "hello", undefined, undefined);
      }));

function run(param) {
  return Parser.run(Simple_sexp_parser.parser, param);
}

var okStringTests = [
  [
    "Empty",
    "\"\"",
    ""
  ],
  [
    "Simple",
    "\"hello\"",
    "hello"
  ],
  [
    "With spaces",
    "    \"  he ll   o  \"",
    "  he ll   o  "
  ]
];

Belt_Array.forEach(okStringTests, (function (param) {
        var expected = param[2];
        var input = param[1];
        return Ava.test("[Sexps.Simple] " + param[0] + " String", (function (t) {
                      var err = Parser.run(Simple_sexp_parser.parser, input);
                      if (err.TAG !== /* Ok */0) {
                        return Ava.fail(t, "Shouldn't failed with \"" + err._0 + "\"", undefined);
                      }
                      var match = err._0;
                      var output = match[0];
                      switch (output.TAG | 0) {
                        case /* String */1 :
                            if (match[1] === "" && output._0 === expected) {
                              return Ava.pass(t, undefined, undefined);
                            }
                            break;
                        case /* Int */0 :
                        case /* Exp */2 :
                            break;
                        
                      }
                      return Ava.fail(t, "Shouldn't succeed with \"" + Simple_sexp_parser.toString(output) + "\" and \"" + match[1] + "\" remaining", undefined);
                    }));
      }));

var okIntTests = [
  [
    "Simple",
    "1",
    "1"
  ],
  [
    "Simple with spaces",
    "    4",
    "4"
  ],
  [
    "More than 9",
    "192",
    "192"
  ],
  [
    "More than 9 with spaces",
    "  8671109    ",
    "8671109"
  ],
  [
    "Negative",
    "-991344",
    "-991344"
  ],
  [
    "Negative with spaces",
    "    -9     ",
    "-9"
  ]
];

Belt_Array.forEach(okIntTests, (function (param) {
        var expected = param[2];
        var input = param[1];
        return Ava.test("[Sexps.Simple] " + param[0] + " Int", (function (t) {
                      var err = Parser.run(Simple_sexp_parser.parser, input);
                      if (err.TAG !== /* Ok */0) {
                        return Ava.fail(t, "Shouldn't failed with \"" + err._0 + "\"", undefined);
                      }
                      var match = err._0;
                      var output = match[0];
                      switch (output.TAG | 0) {
                        case /* Int */0 :
                            if (match[1] === "" && output._0 === expected) {
                              return Ava.pass(t, undefined, undefined);
                            }
                            break;
                        case /* String */1 :
                        case /* Exp */2 :
                            break;
                        
                      }
                      return Ava.fail(t, "Shouldn't succeed with \"" + Simple_sexp_parser.toString(output) + "\" and \"" + match[1] + "\" remaining", undefined);
                    }));
      }));

var okExpTests = [
  [
    "Empty",
    "()",
    {
      TAG: /* Exp */2,
      _0: /* [] */0
    }
  ],
  [
    "Empty with spaces",
    "( )",
    {
      TAG: /* Exp */2,
      _0: /* [] */0
    }
  ],
  [
    "Simple",
    "(1)",
    {
      TAG: /* Exp */2,
      _0: {
        hd: {
          TAG: /* Int */0,
          _0: "1"
        },
        tl: /* [] */0
      }
    }
  ],
  [
    "Simple with spaces",
    " (       1 )    \n  \n  ",
    {
      TAG: /* Exp */2,
      _0: {
        hd: {
          TAG: /* Int */0,
          _0: "1"
        },
        tl: /* [] */0
      }
    }
  ],
  [
    "Multiple",
    "(1 \"2\" 3)",
    {
      TAG: /* Exp */2,
      _0: {
        hd: {
          TAG: /* Int */0,
          _0: "1"
        },
        tl: {
          hd: {
            TAG: /* String */1,
            _0: "2"
          },
          tl: {
            hd: {
              TAG: /* Int */0,
              _0: "3"
            },
            tl: /* [] */0
          }
        }
      }
    }
  ],
  [
    "Multiple with spaces",
    "    (  1  \"2\"     3  )  ",
    {
      TAG: /* Exp */2,
      _0: {
        hd: {
          TAG: /* Int */0,
          _0: "1"
        },
        tl: {
          hd: {
            TAG: /* String */1,
            _0: "2"
          },
          tl: {
            hd: {
              TAG: /* Int */0,
              _0: "3"
            },
            tl: /* [] */0
          }
        }
      }
    }
  ],
  [
    "Nested",
    "(1 (\"2\" 3))",
    {
      TAG: /* Exp */2,
      _0: {
        hd: {
          TAG: /* Int */0,
          _0: "1"
        },
        tl: {
          hd: {
            TAG: /* Exp */2,
            _0: {
              hd: {
                TAG: /* String */1,
                _0: "2"
              },
              tl: {
                hd: {
                  TAG: /* Int */0,
                  _0: "3"
                },
                tl: /* [] */0
              }
            }
          },
          tl: /* [] */0
        }
      }
    }
  ],
  [
    "Nested with spaces",
    "\n  (     1(\"2\"3) )       ",
    {
      TAG: /* Exp */2,
      _0: {
        hd: {
          TAG: /* Int */0,
          _0: "1"
        },
        tl: {
          hd: {
            TAG: /* Exp */2,
            _0: {
              hd: {
                TAG: /* String */1,
                _0: "2"
              },
              tl: {
                hd: {
                  TAG: /* Int */0,
                  _0: "3"
                },
                tl: /* [] */0
              }
            }
          },
          tl: /* [] */0
        }
      }
    }
  ],
  [
    "Deeply nested with spaces",
    "\n  (     1(\"2\"(3 (1 (())))) )       ",
    {
      TAG: /* Exp */2,
      _0: {
        hd: {
          TAG: /* Int */0,
          _0: "1"
        },
        tl: {
          hd: {
            TAG: /* Exp */2,
            _0: {
              hd: {
                TAG: /* String */1,
                _0: "2"
              },
              tl: {
                hd: {
                  TAG: /* Exp */2,
                  _0: {
                    hd: {
                      TAG: /* Int */0,
                      _0: "3"
                    },
                    tl: {
                      hd: {
                        TAG: /* Exp */2,
                        _0: {
                          hd: {
                            TAG: /* Int */0,
                            _0: "1"
                          },
                          tl: {
                            hd: {
                              TAG: /* Exp */2,
                              _0: {
                                hd: {
                                  TAG: /* Exp */2,
                                  _0: /* [] */0
                                },
                                tl: /* [] */0
                              }
                            },
                            tl: /* [] */0
                          }
                        }
                      },
                      tl: /* [] */0
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          },
          tl: /* [] */0
        }
      }
    }
  ]
];

Belt_Array.forEach(okExpTests, (function (param) {
        var expected = param[2];
        var input = param[1];
        return Ava.test("[Sexps.Simple] " + param[0] + " Exp", (function (t) {
                      var err = Parser.run(Simple_sexp_parser.parser, input);
                      if (err.TAG !== /* Ok */0) {
                        return Ava.fail(t, "Shouldn't failed with \"" + err._0 + "\"", undefined);
                      }
                      var match = err._0;
                      var rest = match[1];
                      var output = match[0];
                      if (rest === "" && Caml_obj.caml_equal(output, expected)) {
                        return Ava.pass(t, undefined, undefined);
                      }
                      return Ava.fail(t, "Shouldn't succeed with \"" + Simple_sexp_parser.toString(output) + "\" and \"" + rest + "\" remaining", undefined);
                    }));
      }));

var P;

var Simple;

exports.P = P;
exports.Simple = Simple;
exports.run = run;
exports.okStringTests = okStringTests;
exports.okIntTests = okIntTests;
exports.okExpTests = okExpTests;
/*  Not a pure module */
