// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Char = require("rescript/lib/js/char.js");
var Parser = require("../../src/parser.cjs");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");

function concatStringList(__x) {
  return Belt_List.reduce(__x, "", (function (prim0, prim1) {
                return prim0.concat(prim1);
              }));
}

function charListToString(ls) {
  return concatStringList(Belt_List.map(ls, Char.escaped));
}

var whitespace = Parser.anyOf([
      /* ' ' */32,
      /* '\n' */10,
      /* '\r' */13,
      /* '\t' */9
    ]);

var manyWhitespace = Parser.many(whitespace);

var lParen = Parser.$$char(/* '(' */40);

var rParen = Parser.$$char(/* ')' */41);

var lBracket = Parser.$$char(/* '[' */91);

var rBracket = Parser.$$char(/* ']' */93);

var lBrace = Parser.$$char(/* '{' */123);

var rBrace = Parser.$$char(/* '}' */125);

var hyphen = Parser.$$char(/* '-' */45);

var underbar = Parser.$$char(/* '_' */95);

var uppercase = Parser.satisfy(function (c) {
      if (c >= /* 'a' */97) {
        return /* 'z' */122 >= c;
      } else {
        return false;
      }
    });

var lowercase = Parser.satisfy(function (c) {
      if (c >= /* 'A' */65) {
        return /* 'Z' */90 >= c;
      } else {
        return false;
      }
    });

var zero = Parser.$$char(/* '0' */48);

var oneThroughNine = Parser.satisfy(function (c) {
      if (c >= /* '1' */49) {
        return /* '9' */57 >= c;
      } else {
        return false;
      }
    });

var digit = Parser.orElse(zero, oneThroughNine);

var digits = Parser.map(Parser.map(Parser.atLeastOne(digit), (function (__x) {
            return Belt_List.map(__x, Char.escaped);
          })), concatStringList);

var sign = Parser.anyOf([
      /* '+' */43,
      /* '-' */45
    ]);

var fraction = Parser.map(Parser.andThen(Parser.$$char(/* '.' */46), digits), (function (param) {
        return Char.escaped(param[0]) + param[1];
      }));

function toString(param) {
  var match = param[0];
  return Char.escaped(match[0]) + Belt_Option.getWithDefault(Belt_Option.map(match[1], Char.escaped), "") + param[1];
}

var exponent = Parser.choice([
      Parser.map(Parser.andThen(Parser.andThen(Parser.$$char(/* 'e' */101), Parser.optional(sign)), digits), toString),
      Parser.map(Parser.andThen(Parser.andThen(Parser.$$char(/* 'E' */69), Parser.optional(sign)), digits), toString)
    ]);

function toString$1(param) {
  return Char.escaped(param[0]) + param[1];
}

var oneThroughNineThenDigits = Parser.map(Parser.andThen(oneThroughNine, digits), toString$1);

var signThenDigit = Parser.map(Parser.andThen(Parser.$$char(/* '-' */45), Parser.map(digit, Char.escaped)), toString$1);

var signThenOneThroughNineThenDigits = Parser.map(Parser.andThen(Parser.andThen(Parser.$$char(/* '-' */45), oneThroughNine), digits), (function (param) {
        var match = param[0];
        return Char.escaped(match[0]) + Char.escaped(match[1]) + param[1];
      }));

var integer = Parser.choice([
      oneThroughNineThenDigits,
      Parser.map(digit, Char.escaped),
      signThenOneThroughNineThenDigits,
      signThenDigit
    ]);

var fraction$1 = Parser.optional(fraction);

var exponent$1 = Parser.optional(exponent);

var numberLiteral = Parser.map(Parser.andThen(Parser.andThen(integer, fraction$1), exponent$1), (function (param) {
        var match = param[0];
        return match[0] + Belt_Option.getWithDefault(match[1], "") + Belt_Option.getWithDefault(param[1], "");
      }));

var doubleQuote = Parser.$$char(/* '"' */34);

var unescapedChar = Parser.map(Parser.map(Parser.satisfy(function (ch) {
              if (ch !== /* '\\' */92) {
                return ch !== /* '"' */34;
              } else {
                return false;
              }
            }), (function (prim) {
            return prim;
          })), (function (prim) {
        return String.fromCharCode(prim);
      }));

var escapedChar = Parser.choice(Belt_Array.map([
          [
            "\\/",
            /* '/' */47
          ],
          [
            "\\\"",
            /* '"' */34
          ],
          [
            "\\",
            /* '\\' */92
          ],
          [
            "\b",
            /* '\b' */8
          ],
          [
            "\n",
            /* '\n' */10
          ],
          [
            "\r",
            /* '\r' */13
          ],
          [
            "\t",
            /* '\t' */9
          ]
        ], (function (param) {
            var result = param[1];
            return Parser.map(Parser.string(param[0]), (function (param) {
                          return String.fromCharCode(result);
                        }));
          })));

var backslash = Parser.$$char(/* '\\' */92);

var uChar = Parser.$$char(/* 'u' */117);

var hexdigit = Parser.satisfy(function (c) {
      if (c > 70 || c < 48) {
        return !(c > 102 || c < 97);
      } else {
        return c > 64 || c < 58;
      }
    });

var fourHexDigits = Parser.andThen(Parser.andThen(Parser.andThen(hexdigit, hexdigit), hexdigit), hexdigit);

var unicodeChar = Parser.map(Parser.keepRight(Parser.keepRight(backslash, uChar), fourHexDigits), (function (param) {
        var match = param[0];
        var match$1 = match[0];
        return String.fromCharCode(parseInt(String.fromCharCode(match$1[0], match$1[1], match[1], param[1]), 16));
      }));

var jsChar = Parser.orElse(Parser.orElse(unescapedChar, escapedChar), unicodeChar);

var quotedString = Parser.map(Parser.between(Parser.many(jsChar), doubleQuote, doubleQuote), concatStringList);

var withoutLeadingHyphen = Parser.map(Parser.andThen(Parser.atLeastOne(Parser.choice([
                  uppercase,
                  lowercase,
                  underbar
                ])), Parser.many(Parser.choice([
                  uppercase,
                  lowercase,
                  digit,
                  hyphen,
                  underbar
                ]))), (function (param) {
        return Belt_List.concat(param[0], param[1]);
      }));

var identifier = Parser.map(withoutLeadingHyphen, charListToString);

var literal = Parser.makeRecursive(function (p) {
      var arrayLiteral = Parser.between(Parser.many(p), lBracket, rBracket);
      var pair = Parser.andThen(Parser.keepRight(Parser.$$char(/* ':' */58), identifier), p);
      var pairs = Parser.between(Parser.atLeastOne(pair), manyWhitespace, manyWhitespace);
      var recordLiteral = Parser.keepLeft(Parser.keepRight(lParen, pairs), rParen);
      var keyword = Parser.between(Parser.string("lam"), manyWhitespace, manyWhitespace);
      var arg = Parser.between(identifier, manyWhitespace, manyWhitespace);
      var args = Parser.between(Parser.between(Parser.many(arg), lBracket, rBracket), manyWhitespace, manyWhitespace);
      var lambdaLiteral = Parser.between(Parser.andThen(Parser.keepRight(keyword, args), p), lParen, rParen);
      var named = Parser.map(identifier, (function (name) {
              return {
                      TAG: /* FNamed */0,
                      _0: name
                    };
            }));
      var anon = Parser.map(lambdaLiteral, (function (param) {
              return {
                      TAG: /* FAnon */1,
                      _0: param[0],
                      _1: param[1]
                    };
            }));
      var $$function = Parser.between(Parser.orElse(named, anon), manyWhitespace, manyWhitespace);
      var execution = Parser.between(Parser.andThen($$function, Parser.many(p)), lParen, rParen);
      var variable = Parser.between(Parser.andThen(Parser.keepRight(Parser.between(Parser.string("let"), manyWhitespace, manyWhitespace), Parser.between(identifier, manyWhitespace, manyWhitespace)), p), lParen, rParen);
      var keyword$1 = Parser.between(Parser.string("fun"), manyWhitespace, manyWhitespace);
      var name = Parser.between(identifier, manyWhitespace, manyWhitespace);
      var arg$1 = Parser.between(identifier, manyWhitespace, manyWhitespace);
      var args$1 = Parser.between(Parser.between(Parser.many(arg$1), lBracket, rBracket), manyWhitespace, manyWhitespace);
      var fn = Parser.between(Parser.andThen(Parser.andThen(Parser.keepRight(keyword$1, name), args$1), p), lParen, rParen);
      var blocks = Parser.between(Parser.atLeastOne(Parser.between(Parser.choice([
                        Parser.map(variable, (function (param) {
                                return {
                                        TAG: /* BVariable */0,
                                        _0: param[0],
                                        _1: param[1]
                                      };
                              })),
                        Parser.map(fn, (function (param) {
                                var match = param[0];
                                return {
                                        TAG: /* BFunction */1,
                                        _0: match[0],
                                        _1: match[1],
                                        _2: param[1]
                                      };
                              })),
                        Parser.map(p, (function (literal) {
                                return {
                                        TAG: /* BLiteral */2,
                                        _0: literal
                                      };
                              }))
                      ]), manyWhitespace, manyWhitespace)), lBrace, rBrace);
      return Parser.between(Parser.choice([
                      Parser.map(Parser.string("true"), (function (param) {
                              return /* LTrue */0;
                            })),
                      Parser.map(Parser.string("false"), (function (param) {
                              return /* LFalse */1;
                            })),
                      Parser.map(numberLiteral, (function (n) {
                              return {
                                      TAG: /* LNumber */1,
                                      _0: n
                                    };
                            })),
                      Parser.map(quotedString, (function (s) {
                              return {
                                      TAG: /* LString */2,
                                      _0: s
                                    };
                            })),
                      Parser.map(identifier, (function (i) {
                              return {
                                      TAG: /* LIdentifier */0,
                                      _0: i
                                    };
                            })),
                      Parser.map(arrayLiteral, (function (xs) {
                              return {
                                      TAG: /* LArray */3,
                                      _0: xs
                                    };
                            })),
                      Parser.map(recordLiteral, (function (xs) {
                              return {
                                      TAG: /* LRecord */4,
                                      _0: xs
                                    };
                            })),
                      Parser.map(lambdaLiteral, (function (param) {
                              return {
                                      TAG: /* LLambda */5,
                                      _0: param[0],
                                      _1: param[1]
                                    };
                            })),
                      Parser.map(execution, (function (param) {
                              return {
                                      TAG: /* LExecution */6,
                                      _0: param[0],
                                      _1: param[1]
                                    };
                            })),
                      Parser.map(blocks, (function (blocks) {
                              var match = Belt_List.reverse(blocks);
                              if (!match) {
                                return {
                                        TAG: /* LBlock */7,
                                        _0: blocks,
                                        _1: undefined
                                      };
                              }
                              var head = match.hd;
                              switch (head.TAG | 0) {
                                case /* BVariable */0 :
                                case /* BFunction */1 :
                                    return {
                                            TAG: /* LBlock */7,
                                            _0: blocks,
                                            _1: undefined
                                          };
                                case /* BLiteral */2 :
                                    return {
                                            TAG: /* LBlock */7,
                                            _0: Belt_List.reverse(match.tl),
                                            _1: head._0
                                          };
                                
                              }
                            }))
                    ]), manyWhitespace, manyWhitespace);
    });

var Ast;

var P;

exports.Ast = Ast;
exports.P = P;
exports.literal = literal;
/* whitespace Not a pure module */
