// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Char = require("rescript/lib/js/char.js");
var Parser = require("../../src/parser.cjs");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Lang_sexp_parser__literal = require("./lang_sexp_parser__literal.cjs");
var Lang_sexp_parser__definition = require("./lang_sexp_parser__definition.cjs");

function charListToString(ls) {
  return Belt_List.reduce(Belt_List.map(ls, Char.escaped), "", (function (prim0, prim1) {
                return prim0.concat(prim1);
              }));
}

var whitespace = Parser.anyOf([
      /* ' ' */32,
      /* '\n' */10,
      /* '\r' */13,
      /* '\t' */9
    ]);

var manyWhitespace = Parser.many(whitespace);

var lParen = Parser.$$char(/* '(' */40);

var rParen = Parser.$$char(/* ')' */41);

var lBrace = Parser.$$char(/* '{' */123);

var rBrace = Parser.$$char(/* '}' */125);

var uppercase = Parser.satisfy(function (c) {
      if (c >= /* 'a' */97) {
        return /* 'z' */122 >= c;
      } else {
        return false;
      }
    });

var lowercase = Parser.satisfy(function (c) {
      if (c >= /* 'A' */65) {
        return /* 'Z' */90 >= c;
      } else {
        return false;
      }
    });

var moduleIdentifier = Parser.map(Parser.atLeastOne(Parser.choice([
              uppercase,
              lowercase
            ])), charListToString);

var parser = Parser.map(Parser.between(Parser.andThen(Parser.keepRight(Parser.between(Parser.string("module"), manyWhitespace, manyWhitespace), Parser.between(moduleIdentifier, manyWhitespace, manyWhitespace)), Parser.between(Parser.many(Lang_sexp_parser__definition.definition), lBrace, rBrace)), lParen, rParen), (function (param) {
        var match = Belt_List.partition(param[1], (function (x) {
                if (x.TAG === /* DExport */3) {
                  return true;
                } else {
                  return false;
                }
              }));
        var $$exports = Belt_List.keepMap(match[0], (function (x) {
                if (x.TAG === /* DExport */3) {
                  return [
                          x._0,
                          x._1
                        ];
                }
                
              }));
        return /* Module */{
                _0: param[0],
                _1: match[1],
                _2: $$exports
              };
      }));

var Ast;

var P;

var literal = Lang_sexp_parser__literal.literal;

var definition = Lang_sexp_parser__definition.definition;

exports.Ast = Ast;
exports.P = P;
exports.literal = literal;
exports.definition = definition;
exports.parser = parser;
/* whitespace Not a pure module */
