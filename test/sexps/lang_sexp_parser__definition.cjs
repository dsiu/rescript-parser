// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Char = require("rescript/lib/js/char.js");
var Parser = require("../../src/parser.cjs");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Lang_sexp_parser__literal = require("./lang_sexp_parser__literal.cjs");

function charListToString(ls) {
  return Belt_List.reduce(Belt_List.map(ls, Char.escaped), "", (function (prim0, prim1) {
                return prim0.concat(prim1);
              }));
}

var whitespace = Parser.anyOf([
      /* ' ' */32,
      /* '\n' */10,
      /* '\r' */13,
      /* '\t' */9
    ]);

var manyWhitespace = Parser.many(whitespace);

var lParen = Parser.$$char(/* '(' */40);

var rParen = Parser.$$char(/* ')' */41);

var lBracket = Parser.$$char(/* '[' */91);

var rBracket = Parser.$$char(/* ']' */93);

var lBrace = Parser.$$char(/* '{' */123);

var rBrace = Parser.$$char(/* '}' */125);

var hyphen = Parser.$$char(/* '-' */45);

var underbar = Parser.$$char(/* '_' */95);

var digit = Parser.satisfy(function (c) {
      if (c >= /* '0' */48) {
        return /* '9' */57 >= c;
      } else {
        return false;
      }
    });

var uppercase = Parser.satisfy(function (c) {
      if (c >= /* 'a' */97) {
        return /* 'z' */122 >= c;
      } else {
        return false;
      }
    });

var lowercase = Parser.satisfy(function (c) {
      if (c >= /* 'A' */65) {
        return /* 'Z' */90 >= c;
      } else {
        return false;
      }
    });

var withoutLeadingHyphen = Parser.map(Parser.andThen(Parser.atLeastOne(Parser.choice([
                  uppercase,
                  lowercase,
                  underbar
                ])), Parser.many(Parser.choice([
                  uppercase,
                  lowercase,
                  digit,
                  hyphen,
                  underbar
                ]))), (function (param) {
        return Belt_List.concat(param[0], param[1]);
      }));

var identifier = Parser.map(withoutLeadingHyphen, charListToString);

var definition = Parser.makeRecursive(function (def) {
      var export_ = Parser.between(Parser.andThen(Parser.keepRight(Parser.between(Parser.string("export"), manyWhitespace, manyWhitespace), Parser.between(identifier, manyWhitespace, manyWhitespace)), Lang_sexp_parser__literal.literal), lParen, rParen);
      var variable = Parser.between(Parser.andThen(Parser.keepRight(Parser.between(Parser.string("let"), manyWhitespace, manyWhitespace), Parser.between(identifier, manyWhitespace, manyWhitespace)), Lang_sexp_parser__literal.literal), lParen, rParen);
      var keyword = Parser.between(Parser.string("fun"), manyWhitespace, manyWhitespace);
      var name = Parser.between(identifier, manyWhitespace, manyWhitespace);
      var arg = Parser.between(identifier, manyWhitespace, manyWhitespace);
      var args = Parser.between(Parser.between(Parser.many(arg), lBracket, rBracket), manyWhitespace, manyWhitespace);
      var fn = Parser.between(Parser.andThen(Parser.andThen(Parser.keepRight(keyword, name), args), Lang_sexp_parser__literal.literal), lParen, rParen);
      var module_ = Parser.between(Parser.andThen(Parser.keepRight(Parser.between(Parser.string("module"), manyWhitespace, manyWhitespace), Parser.between(identifier, manyWhitespace, manyWhitespace)), Parser.between(Parser.many(def), lBrace, rBrace)), lParen, rParen);
      var moduleDef = Parser.map(module_, (function (param) {
              var match = Belt_List.partition(param[1], (function (x) {
                      if (x.TAG === /* DExport */3) {
                        return true;
                      } else {
                        return false;
                      }
                    }));
              var $$exports = Belt_List.keepMap(match[0], (function (x) {
                      if (x.TAG === /* DExport */3) {
                        return [
                                x._0,
                                x._1
                              ];
                      }
                      
                    }));
              return /* Module */{
                      _0: param[0],
                      _1: match[1],
                      _2: $$exports
                    };
            }));
      return Parser.between(Parser.choice([
                      Parser.map(variable, (function (param) {
                              return {
                                      TAG: /* DVariable */0,
                                      _0: param[0],
                                      _1: param[1]
                                    };
                            })),
                      Parser.map(fn, (function (param) {
                              var match = param[0];
                              return {
                                      TAG: /* DFunction */1,
                                      _0: match[0],
                                      _1: match[1],
                                      _2: param[1]
                                    };
                            })),
                      Parser.map(moduleDef, (function (m) {
                              return {
                                      TAG: /* DModule */2,
                                      _0: m
                                    };
                            })),
                      Parser.map(export_, (function (param) {
                              return {
                                      TAG: /* DExport */3,
                                      _0: param[0],
                                      _1: param[1]
                                    };
                            }))
                    ]), manyWhitespace, manyWhitespace);
    });

var Ast;

var P;

exports.Ast = Ast;
exports.P = P;
exports.definition = definition;
/* whitespace Not a pure module */
